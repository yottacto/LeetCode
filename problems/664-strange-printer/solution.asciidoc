== problem info

difficulty: hard
tags: dp


== main idea

动态规划，一开始想了一个 `dp[l][r]` 但是转移想成了枚举 `[l, r]` 内的一段染色区间
`[i, j]` ，然后得到 `dp[l][r] = min(dp[l, i - 1] + dp[i + 1][j - 1] + dp[j + 1][r] + 1)` 。
但是这样有点问题，这相当于是枚举了实际中绝对的一次打印，但是这样可能 `dp[i + 1][j - 1]`
会被多算，因为实际上这一段已经被一个字母覆盖了，里面相同的字母其实如果没被别的
字母覆盖的话不用另外的费用，为了维持这个转移的合法性，需要扩充状态为 `f[l][r][cover]`
来表示上这段区间覆盖的颜色。这样做加点优化也能过，但是会非常慢。

事实上转移有更简单的方法。对于区间 `[l, r]`, 我们每次只需要找满足 `s[r] == s[k]`
的中间点 `k` 然后进行转移 `dp[l][r] = dp[l][k] + dp[k + 1][r - 1]` ，然后还有 normal case,
`dp[l][r] = dp[l][r - 1] + 1`, 如果 `l > r` 那么 `dp[l][r] = 0` 。
对于上面的转移方程， 区间 `[k, r]` 的打印费用被算在了 `dp[l][k]` 的最后一个 `k` 之中，
这和之前的转移的区别是没有一次划死区间范围，而是能够将相同的节点 `k, r` 一通归并到 `[l, k]`
中求解最优转移。比如对于字符串 `aabcba`, 假设下标从 `0` 开始，对于第一次转移 `dp[0][5]`
找到的 `k = 1`, 那么实际相当于求解 `aaaaaa` + `bcb`, 两个最小次数和。

上面这种总转移用记忆化搜索很容易实现，也可以通过区间合并的思路进行递推求解。
对于两个相邻区间如果边界上有相同字母，两个区间费用相加减一即可。

